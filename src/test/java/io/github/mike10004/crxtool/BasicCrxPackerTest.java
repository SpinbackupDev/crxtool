package io.github.mike10004.crxtool;

import com.google.common.io.BaseEncoding;
import com.google.common.io.ByteSource;
import com.google.common.io.ByteStreams;
import com.google.common.io.CountingOutputStream;
import com.google.common.io.Files;
import com.google.common.io.LittleEndianDataOutputStream;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URISyntaxException;
import java.security.KeyPair;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class BasicCrxPackerTest {

    /**
     * Chops the header off a CRX file and writes the zip bytes to a file.
     *
     * <p>We compare the packer's output with a reference CRX file generated by
     * Chrome on the command line with {@code --pack-extension}. In order for the
     * signatures to match, we need the exact zip byte that are produced by that method.
     * Whatever method it is, it's different from how Java's standard library zips things
     * and E. Gordon's Zip 3.0. There are many ways to zip a directory.
     * @return the zip file
     */
    private File chopZipFromCrx() throws IOException, URISyntaxException {
        File choppedFile = new File("/tmp/chopped.zip");
        File referenceCrxFile = new File(getClass().getResource("/make_page_red.crx").toURI());
        try (InputStream in = new FileInputStream(referenceCrxFile)) {
            CrxParser.getDefault().parseMetadata(in);
            try (OutputStream out = new FileOutputStream(choppedFile)) {
                ByteStreams.copy(in, out);
            }
        }
//        System.out.format("%s (%d bytes)%n", referenceCrxFile, referenceCrxFile.length());
//        System.out.format("%s (%d bytes)%n", choppedFile, choppedFile.length());
//        System.out.format("header length %d bytes%n", referenceCrxFile.length() - choppedFile.length());
        return choppedFile;
    }

    @Test
    public void packExtension() throws Exception {
        File extensionZipFile = chopZipFromCrx();
        ByteSource extensionZip = Files.asByteSource(extensionZipFile);
        BasicCrxPacker packer = new BasicCrxPacker();
        KeyPair keyPair = KeyPairs.loadRsaKeyPairFromPrivateKeyBytes(TestKey.getPrivateKeyBytes());
        File extensionFile = File.createTempFile("crxtool-unit-test", ".crx");
        try (OutputStream outputStream = new FileOutputStream(extensionFile)) {
            packer.packExtension(extensionZip, keyPair, outputStream);
        }
        CrxMetadata actualMetadata = readMetadata(extensionFile);
        File referenceCrxFile = new File(getClass().getResource("/make_page_red.crx").toURI());
        CrxMetadata expectedMetadata = readMetadata(referenceCrxFile);
        assertEquals("magic number", expectedMetadata.magicNumber, actualMetadata.magicNumber);
        assertEquals("version", expectedMetadata.version, actualMetadata.version);
        assertEquals("pubkey.length", expectedMetadata.pubkeyLength, actualMetadata.pubkeyLength);
        assertEquals("sig.length", expectedMetadata.signatureLength, actualMetadata.signatureLength);
        assertEquals("pubkey", expectedMetadata.pubkeyBase64, actualMetadata.pubkeyBase64);
        assertEquals("sig", expectedMetadata.signatureBase64, actualMetadata.signatureBase64);
        assertTrue("crx bytes", Files.asByteSource(referenceCrxFile).contentEquals(Files.asByteSource(extensionFile)));

    }

    private CrxMetadata readMetadata(File crxFile) throws IOException {
        try (InputStream inputStream = new FileInputStream(crxFile)) {
            return CrxParser.getDefault().parseMetadata(inputStream);
        }
    }

    private static final String FORMAT_VERSION_HEX = "02000000";

    @Test
    public void writeFormatVersion() throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream(32);
        CountingOutputStream counter = new CountingOutputStream(buffer);
        LittleEndianDataOutputStream output = new LittleEndianDataOutputStream(counter);
        new BasicCrxPacker().writeFormatVersion(output);
        output.flush();
        long count = counter.getCount();
        assertEquals("byte count", 4, count);
        byte[] expected = BaseEncoding.base16().decode(FORMAT_VERSION_HEX);
        byte[] actual = buffer.toByteArray();
//        System.out.format("%s%n", BaseEncoding.base16().encode(actual));
        assertArrayEquals("version encoding", expected, actual);
    }
}