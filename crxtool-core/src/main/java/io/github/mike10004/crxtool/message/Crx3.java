// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: crx3.proto

package io.github.mike10004.crxtool.message;

public final class Crx3 {
  private Crx3() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface CrxFileHeaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.CrxFileHeader)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> 
        getSha256WithRsaList();
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithRsa(int index);
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    int getSha256WithRsaCount();

    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> 
        getSha256WithEcdsaList();
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index);
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    int getSha256WithEcdsaCount();

    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     */
    boolean hasSignedHeaderData();
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     */
    com.google.protobuf.ByteString getSignedHeaderData();
  }
  /**
   * Protobuf type {@code crx_file.CrxFileHeader}
   */
  public  static final class CrxFileHeader extends
      com.google.protobuf.GeneratedMessageLite<
          CrxFileHeader, CrxFileHeader.Builder> implements
      // @@protoc_insertion_point(message_implements:crx_file.CrxFileHeader)
      CrxFileHeaderOrBuilder {
    private CrxFileHeader() {
      sha256WithRsa_ = emptyProtobufList();
      sha256WithEcdsa_ = emptyProtobufList();
      signedHeaderData_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int SHA256_WITH_RSA_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> sha256WithRsa_;
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithRsaList() {
      return sha256WithRsa_;
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithRsaOrBuilderList() {
      return sha256WithRsa_;
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    @java.lang.Override
    public int getSha256WithRsaCount() {
      return sha256WithRsa_.size();
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    @java.lang.Override
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithRsa(int index) {
      return sha256WithRsa_.get(index);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithRsaOrBuilder(
        int index) {
      return sha256WithRsa_.get(index);
    }
    private void ensureSha256WithRsaIsMutable() {
      if (!sha256WithRsa_.isModifiable()) {
        sha256WithRsa_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(sha256WithRsa_);
       }
    }

    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void setSha256WithRsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.set(index, value);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void setSha256WithRsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addSha256WithRsa(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.add(value);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addSha256WithRsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.add(index, value);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addSha256WithRsa(
        io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.add(builderForValue.build());
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addSha256WithRsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addAllSha256WithRsa(
        java.lang.Iterable<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> values) {
      ensureSha256WithRsaIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, sha256WithRsa_);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void clearSha256WithRsa() {
      sha256WithRsa_ = emptyProtobufList();
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void removeSha256WithRsa(int index) {
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.remove(index);
    }

    public static final int SHA256_WITH_ECDSA_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> sha256WithEcdsa_;
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    @java.lang.Override
    public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithEcdsaList() {
      return sha256WithEcdsa_;
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithEcdsaOrBuilderList() {
      return sha256WithEcdsa_;
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    @java.lang.Override
    public int getSha256WithEcdsaCount() {
      return sha256WithEcdsa_.size();
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    @java.lang.Override
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index) {
      return sha256WithEcdsa_.get(index);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithEcdsaOrBuilder(
        int index) {
      return sha256WithEcdsa_.get(index);
    }
    private void ensureSha256WithEcdsaIsMutable() {
      if (!sha256WithEcdsa_.isModifiable()) {
        sha256WithEcdsa_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(sha256WithEcdsa_);
       }
    }

    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void setSha256WithEcdsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.set(index, value);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void setSha256WithEcdsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addSha256WithEcdsa(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.add(value);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addSha256WithEcdsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.add(index, value);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addSha256WithEcdsa(
        io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.add(builderForValue.build());
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addSha256WithEcdsa(
        int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addAllSha256WithEcdsa(
        java.lang.Iterable<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> values) {
      ensureSha256WithEcdsaIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, sha256WithEcdsa_);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void clearSha256WithEcdsa() {
      sha256WithEcdsa_ = emptyProtobufList();
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void removeSha256WithEcdsa(int index) {
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.remove(index);
    }

    public static final int SIGNED_HEADER_DATA_FIELD_NUMBER = 10000;
    private com.google.protobuf.ByteString signedHeaderData_;
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     */
    @java.lang.Override
    public boolean hasSignedHeaderData() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignedHeaderData() {
      return signedHeaderData_;
    }
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     */
    private void setSignedHeaderData(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      signedHeaderData_ = value;
    }
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     */
    private void clearSignedHeaderData() {
      bitField0_ = (bitField0_ & ~0x00000001);
      signedHeaderData_ = getDefaultInstance().getSignedHeaderData();
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < sha256WithRsa_.size(); i++) {
        output.writeMessage(2, sha256WithRsa_.get(i));
      }
      for (int i = 0; i < sha256WithEcdsa_.size(); i++) {
        output.writeMessage(3, sha256WithEcdsa_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(10000, signedHeaderData_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < sha256WithRsa_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, sha256WithRsa_.get(i));
      }
      for (int i = 0; i < sha256WithEcdsa_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, sha256WithEcdsa_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(10000, signedHeaderData_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(io.github.mike10004.crxtool.message.Crx3.CrxFileHeader prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code crx_file.CrxFileHeader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          io.github.mike10004.crxtool.message.Crx3.CrxFileHeader, Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.CrxFileHeader)
        io.github.mike10004.crxtool.message.Crx3.CrxFileHeaderOrBuilder {
      // Construct using io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      @java.lang.Override
      public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithRsaList() {
        return java.util.Collections.unmodifiableList(
            instance.getSha256WithRsaList());
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      @java.lang.Override
      public int getSha256WithRsaCount() {
        return instance.getSha256WithRsaCount();
      }/**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithRsa(int index) {
        return instance.getSha256WithRsa(index);
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder setSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.setSha256WithRsa(index, value);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder setSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.setSha256WithRsa(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithRsa(value);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithRsa(index, value);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithRsa(builderForValue);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithRsa(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addAllSha256WithRsa(
          java.lang.Iterable<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> values) {
        copyOnWrite();
        instance.addAllSha256WithRsa(values);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder clearSha256WithRsa() {
        copyOnWrite();
        instance.clearSha256WithRsa();
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder removeSha256WithRsa(int index) {
        copyOnWrite();
        instance.removeSha256WithRsa(index);
        return this;
      }

      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      @java.lang.Override
      public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithEcdsaList() {
        return java.util.Collections.unmodifiableList(
            instance.getSha256WithEcdsaList());
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      @java.lang.Override
      public int getSha256WithEcdsaCount() {
        return instance.getSha256WithEcdsaCount();
      }/**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index) {
        return instance.getSha256WithEcdsa(index);
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder setSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.setSha256WithEcdsa(index, value);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder setSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.setSha256WithEcdsa(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithEcdsa(value);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithEcdsa(index, value);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithEcdsa(builderForValue);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithEcdsa(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addAllSha256WithEcdsa(
          java.lang.Iterable<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> values) {
        copyOnWrite();
        instance.addAllSha256WithEcdsa(values);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder clearSha256WithEcdsa() {
        copyOnWrite();
        instance.clearSha256WithEcdsa();
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder removeSha256WithEcdsa(int index) {
        copyOnWrite();
        instance.removeSha256WithEcdsa(index);
        return this;
      }

      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       */
      @java.lang.Override
      public boolean hasSignedHeaderData() {
        return instance.hasSignedHeaderData();
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignedHeaderData() {
        return instance.getSignedHeaderData();
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       */
      public Builder setSignedHeaderData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignedHeaderData(value);
        return this;
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       */
      public Builder clearSignedHeaderData() {
        copyOnWrite();
        instance.clearSignedHeaderData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:crx_file.CrxFileHeader)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new io.github.mike10004.crxtool.message.Crx3.CrxFileHeader();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          sha256WithRsa_.makeImmutable();
          sha256WithEcdsa_.makeImmutable();
          return null;
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          io.github.mike10004.crxtool.message.Crx3.CrxFileHeader other = (io.github.mike10004.crxtool.message.Crx3.CrxFileHeader) arg1;
          sha256WithRsa_= visitor.visitList(sha256WithRsa_, other.sha256WithRsa_);
          sha256WithEcdsa_= visitor.visitList(sha256WithEcdsa_, other.sha256WithEcdsa_);
          signedHeaderData_ = visitor.visitByteString(
              hasSignedHeaderData(), signedHeaderData_,
              other.hasSignedHeaderData(), other.signedHeaderData_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 18: {
                  if (!sha256WithRsa_.isModifiable()) {
                    sha256WithRsa_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(sha256WithRsa_);
                  }
                  sha256WithRsa_.add(
                      input.readMessage(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.parser(), extensionRegistry));
                  break;
                }
                case 26: {
                  if (!sha256WithEcdsa_.isModifiable()) {
                    sha256WithEcdsa_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(sha256WithEcdsa_);
                  }
                  sha256WithEcdsa_.add(
                      input.readMessage(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.parser(), extensionRegistry));
                  break;
                }
                case 80002: {
                  bitField0_ |= 0x00000001;
                  signedHeaderData_ = input.readBytes();
                  break;
                }
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<io.github.mike10004.crxtool.message.Crx3.CrxFileHeader> parser = PARSER;
          if (parser == null) {
            synchronized (io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.class) {
              parser = PARSER;
              if (parser == null) {
                parser = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:crx_file.CrxFileHeader)
    private static final io.github.mike10004.crxtool.message.Crx3.CrxFileHeader DEFAULT_INSTANCE;
    static {
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = new CrxFileHeader();
    }

    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CrxFileHeader> PARSER;

    public static com.google.protobuf.Parser<CrxFileHeader> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AsymmetricKeyProofOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.AsymmetricKeyProof)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional bytes public_key = 1;</code>
     */
    boolean hasPublicKey();
    /**
     * <code>optional bytes public_key = 1;</code>
     */
    com.google.protobuf.ByteString getPublicKey();

    /**
     * <code>optional bytes signature = 2;</code>
     */
    boolean hasSignature();
    /**
     * <code>optional bytes signature = 2;</code>
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * Protobuf type {@code crx_file.AsymmetricKeyProof}
   */
  public  static final class AsymmetricKeyProof extends
      com.google.protobuf.GeneratedMessageLite<
          AsymmetricKeyProof, AsymmetricKeyProof.Builder> implements
      // @@protoc_insertion_point(message_implements:crx_file.AsymmetricKeyProof)
      AsymmetricKeyProofOrBuilder {
    private AsymmetricKeyProof() {
      publicKey_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int PUBLIC_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString publicKey_;
    /**
     * <code>optional bytes public_key = 1;</code>
     */
    @java.lang.Override
    public boolean hasPublicKey() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional bytes public_key = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPublicKey() {
      return publicKey_;
    }
    /**
     * <code>optional bytes public_key = 1;</code>
     */
    private void setPublicKey(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      publicKey_ = value;
    }
    /**
     * <code>optional bytes public_key = 1;</code>
     */
    private void clearPublicKey() {
      bitField0_ = (bitField0_ & ~0x00000001);
      publicKey_ = getDefaultInstance().getPublicKey();
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString signature_;
    /**
     * <code>optional bytes signature = 2;</code>
     */
    @java.lang.Override
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional bytes signature = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <code>optional bytes signature = 2;</code>
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      signature_ = value;
    }
    /**
     * <code>optional bytes signature = 2;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000002);
      signature_ = getDefaultInstance().getSignature();
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, publicKey_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, signature_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, publicKey_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, signature_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code crx_file.AsymmetricKeyProof}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof, Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.AsymmetricKeyProof)
        io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder {
      // Construct using io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional bytes public_key = 1;</code>
       */
      @java.lang.Override
      public boolean hasPublicKey() {
        return instance.hasPublicKey();
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPublicKey() {
        return instance.getPublicKey();
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       */
      public Builder setPublicKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPublicKey(value);
        return this;
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       */
      public Builder clearPublicKey() {
        copyOnWrite();
        instance.clearPublicKey();
        return this;
      }

      /**
       * <code>optional bytes signature = 2;</code>
       */
      @java.lang.Override
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <code>optional bytes signature = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <code>optional bytes signature = 2;</code>
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <code>optional bytes signature = 2;</code>
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:crx_file.AsymmetricKeyProof)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof other = (io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof) arg1;
          publicKey_ = visitor.visitByteString(
              hasPublicKey(), publicKey_,
              other.hasPublicKey(), other.publicKey_);
          signature_ = visitor.visitByteString(
              hasSignature(), signature_,
              other.hasSignature(), other.signature_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  bitField0_ |= 0x00000001;
                  publicKey_ = input.readBytes();
                  break;
                }
                case 18: {
                  bitField0_ |= 0x00000002;
                  signature_ = input.readBytes();
                  break;
                }
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> parser = PARSER;
          if (parser == null) {
            synchronized (io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.class) {
              parser = PARSER;
              if (parser == null) {
                parser = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:crx_file.AsymmetricKeyProof)
    private static final io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof DEFAULT_INSTANCE;
    static {
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = new AsymmetricKeyProof();
    }

    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AsymmetricKeyProof> PARSER;

    public static com.google.protobuf.Parser<AsymmetricKeyProof> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SignedDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.SignedData)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     */
    boolean hasCrxId();
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     */
    com.google.protobuf.ByteString getCrxId();
  }
  /**
   * Protobuf type {@code crx_file.SignedData}
   */
  public  static final class SignedData extends
      com.google.protobuf.GeneratedMessageLite<
          SignedData, SignedData.Builder> implements
      // @@protoc_insertion_point(message_implements:crx_file.SignedData)
      SignedDataOrBuilder {
    private SignedData() {
      crxId_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int CRX_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString crxId_;
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     */
    @java.lang.Override
    public boolean hasCrxId() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCrxId() {
      return crxId_;
    }
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     */
    private void setCrxId(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      crxId_ = value;
    }
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     */
    private void clearCrxId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      crxId_ = getDefaultInstance().getCrxId();
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, crxId_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, crxId_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(io.github.mike10004.crxtool.message.Crx3.SignedData prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code crx_file.SignedData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          io.github.mike10004.crxtool.message.Crx3.SignedData, Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.SignedData)
        io.github.mike10004.crxtool.message.Crx3.SignedDataOrBuilder {
      // Construct using io.github.mike10004.crxtool.message.Crx3.SignedData.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       */
      @java.lang.Override
      public boolean hasCrxId() {
        return instance.hasCrxId();
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCrxId() {
        return instance.getCrxId();
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       */
      public Builder setCrxId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCrxId(value);
        return this;
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       */
      public Builder clearCrxId() {
        copyOnWrite();
        instance.clearCrxId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:crx_file.SignedData)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new io.github.mike10004.crxtool.message.Crx3.SignedData();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          io.github.mike10004.crxtool.message.Crx3.SignedData other = (io.github.mike10004.crxtool.message.Crx3.SignedData) arg1;
          crxId_ = visitor.visitByteString(
              hasCrxId(), crxId_,
              other.hasCrxId(), other.crxId_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  bitField0_ |= 0x00000001;
                  crxId_ = input.readBytes();
                  break;
                }
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<io.github.mike10004.crxtool.message.Crx3.SignedData> parser = PARSER;
          if (parser == null) {
            synchronized (io.github.mike10004.crxtool.message.Crx3.SignedData.class) {
              parser = PARSER;
              if (parser == null) {
                parser = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:crx_file.SignedData)
    private static final io.github.mike10004.crxtool.message.Crx3.SignedData DEFAULT_INSTANCE;
    static {
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = new SignedData();
    }

    public static io.github.mike10004.crxtool.message.Crx3.SignedData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SignedData> PARSER;

    public static com.google.protobuf.Parser<SignedData> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
