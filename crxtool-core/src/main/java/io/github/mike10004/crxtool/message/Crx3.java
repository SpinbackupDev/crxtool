// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main/chromium/crx3.proto

package io.github.mike10004.crxtool.message;

public final class Crx3 {
  private Crx3() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface CrxFileHeaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.CrxFileHeader)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> 
        getSha256WithRsaList();
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithRsa(int index);
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    int getSha256WithRsaCount();
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithRsaOrBuilderList();
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithRsaOrBuilder(
        int index);

    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> 
        getSha256WithEcdsaList();
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index);
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    int getSha256WithEcdsaCount();
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithEcdsaOrBuilderList();
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithEcdsaOrBuilder(
        int index);

    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return Whether the signedHeaderData field is set.
     */
    boolean hasSignedHeaderData();
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return The signedHeaderData.
     */
    com.google.protobuf.ByteString getSignedHeaderData();
  }
  /**
   * Protobuf type {@code crx_file.CrxFileHeader}
   */
  public  static final class CrxFileHeader extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:crx_file.CrxFileHeader)
      CrxFileHeaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CrxFileHeader.newBuilder() to construct.
    private CrxFileHeader(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CrxFileHeader() {
      sha256WithRsa_ = java.util.Collections.emptyList();
      sha256WithEcdsa_ = java.util.Collections.emptyList();
      signedHeaderData_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CrxFileHeader();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CrxFileHeader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 18: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                sha256WithRsa_ = new java.util.ArrayList<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof>();
                mutable_bitField0_ |= 0x00000001;
              }
              sha256WithRsa_.add(
                  input.readMessage(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.PARSER, extensionRegistry));
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                sha256WithEcdsa_ = new java.util.ArrayList<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof>();
                mutable_bitField0_ |= 0x00000002;
              }
              sha256WithEcdsa_.add(
                  input.readMessage(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.PARSER, extensionRegistry));
              break;
            }
            case 80002: {
              bitField0_ |= 0x00000001;
              signedHeaderData_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          sha256WithRsa_ = java.util.Collections.unmodifiableList(sha256WithRsa_);
        }
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          sha256WithEcdsa_ = java.util.Collections.unmodifiableList(sha256WithEcdsa_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_CrxFileHeader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_CrxFileHeader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.class, io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.Builder.class);
    }

    private int bitField0_;
    public static final int SHA256_WITH_RSA_FIELD_NUMBER = 2;
    private java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> sha256WithRsa_;
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithRsaList() {
      return sha256WithRsa_;
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithRsaOrBuilderList() {
      return sha256WithRsa_;
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public int getSha256WithRsaCount() {
      return sha256WithRsa_.size();
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithRsa(int index) {
      return sha256WithRsa_.get(index);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithRsaOrBuilder(
        int index) {
      return sha256WithRsa_.get(index);
    }

    public static final int SHA256_WITH_ECDSA_FIELD_NUMBER = 3;
    private java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> sha256WithEcdsa_;
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithEcdsaList() {
      return sha256WithEcdsa_;
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithEcdsaOrBuilderList() {
      return sha256WithEcdsa_;
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public int getSha256WithEcdsaCount() {
      return sha256WithEcdsa_.size();
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index) {
      return sha256WithEcdsa_.get(index);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithEcdsaOrBuilder(
        int index) {
      return sha256WithEcdsa_.get(index);
    }

    public static final int SIGNED_HEADER_DATA_FIELD_NUMBER = 10000;
    private com.google.protobuf.ByteString signedHeaderData_;
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return Whether the signedHeaderData field is set.
     */
    public boolean hasSignedHeaderData() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return The signedHeaderData.
     */
    public com.google.protobuf.ByteString getSignedHeaderData() {
      return signedHeaderData_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < sha256WithRsa_.size(); i++) {
        output.writeMessage(2, sha256WithRsa_.get(i));
      }
      for (int i = 0; i < sha256WithEcdsa_.size(); i++) {
        output.writeMessage(3, sha256WithEcdsa_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(10000, signedHeaderData_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < sha256WithRsa_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, sha256WithRsa_.get(i));
      }
      for (int i = 0; i < sha256WithEcdsa_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, sha256WithEcdsa_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(10000, signedHeaderData_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.github.mike10004.crxtool.message.Crx3.CrxFileHeader)) {
        return super.equals(obj);
      }
      io.github.mike10004.crxtool.message.Crx3.CrxFileHeader other = (io.github.mike10004.crxtool.message.Crx3.CrxFileHeader) obj;

      if (!getSha256WithRsaList()
          .equals(other.getSha256WithRsaList())) return false;
      if (!getSha256WithEcdsaList()
          .equals(other.getSha256WithEcdsaList())) return false;
      if (hasSignedHeaderData() != other.hasSignedHeaderData()) return false;
      if (hasSignedHeaderData()) {
        if (!getSignedHeaderData()
            .equals(other.getSignedHeaderData())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getSha256WithRsaCount() > 0) {
        hash = (37 * hash) + SHA256_WITH_RSA_FIELD_NUMBER;
        hash = (53 * hash) + getSha256WithRsaList().hashCode();
      }
      if (getSha256WithEcdsaCount() > 0) {
        hash = (37 * hash) + SHA256_WITH_ECDSA_FIELD_NUMBER;
        hash = (53 * hash) + getSha256WithEcdsaList().hashCode();
      }
      if (hasSignedHeaderData()) {
        hash = (37 * hash) + SIGNED_HEADER_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getSignedHeaderData().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.github.mike10004.crxtool.message.Crx3.CrxFileHeader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code crx_file.CrxFileHeader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.CrxFileHeader)
        io.github.mike10004.crxtool.message.Crx3.CrxFileHeaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_CrxFileHeader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_CrxFileHeader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.class, io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.Builder.class);
      }

      // Construct using io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSha256WithRsaFieldBuilder();
          getSha256WithEcdsaFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (sha256WithRsaBuilder_ == null) {
          sha256WithRsa_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          sha256WithRsaBuilder_.clear();
        }
        if (sha256WithEcdsaBuilder_ == null) {
          sha256WithEcdsa_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          sha256WithEcdsaBuilder_.clear();
        }
        signedHeaderData_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_CrxFileHeader_descriptor;
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.CrxFileHeader getDefaultInstanceForType() {
        return io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.getDefaultInstance();
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.CrxFileHeader build() {
        io.github.mike10004.crxtool.message.Crx3.CrxFileHeader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.CrxFileHeader buildPartial() {
        io.github.mike10004.crxtool.message.Crx3.CrxFileHeader result = new io.github.mike10004.crxtool.message.Crx3.CrxFileHeader(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (sha256WithRsaBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            sha256WithRsa_ = java.util.Collections.unmodifiableList(sha256WithRsa_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.sha256WithRsa_ = sha256WithRsa_;
        } else {
          result.sha256WithRsa_ = sha256WithRsaBuilder_.build();
        }
        if (sha256WithEcdsaBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            sha256WithEcdsa_ = java.util.Collections.unmodifiableList(sha256WithEcdsa_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.sha256WithEcdsa_ = sha256WithEcdsa_;
        } else {
          result.sha256WithEcdsa_ = sha256WithEcdsaBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.signedHeaderData_ = signedHeaderData_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.github.mike10004.crxtool.message.Crx3.CrxFileHeader) {
          return mergeFrom((io.github.mike10004.crxtool.message.Crx3.CrxFileHeader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.github.mike10004.crxtool.message.Crx3.CrxFileHeader other) {
        if (other == io.github.mike10004.crxtool.message.Crx3.CrxFileHeader.getDefaultInstance()) return this;
        if (sha256WithRsaBuilder_ == null) {
          if (!other.sha256WithRsa_.isEmpty()) {
            if (sha256WithRsa_.isEmpty()) {
              sha256WithRsa_ = other.sha256WithRsa_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureSha256WithRsaIsMutable();
              sha256WithRsa_.addAll(other.sha256WithRsa_);
            }
            onChanged();
          }
        } else {
          if (!other.sha256WithRsa_.isEmpty()) {
            if (sha256WithRsaBuilder_.isEmpty()) {
              sha256WithRsaBuilder_.dispose();
              sha256WithRsaBuilder_ = null;
              sha256WithRsa_ = other.sha256WithRsa_;
              bitField0_ = (bitField0_ & ~0x00000001);
              sha256WithRsaBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSha256WithRsaFieldBuilder() : null;
            } else {
              sha256WithRsaBuilder_.addAllMessages(other.sha256WithRsa_);
            }
          }
        }
        if (sha256WithEcdsaBuilder_ == null) {
          if (!other.sha256WithEcdsa_.isEmpty()) {
            if (sha256WithEcdsa_.isEmpty()) {
              sha256WithEcdsa_ = other.sha256WithEcdsa_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureSha256WithEcdsaIsMutable();
              sha256WithEcdsa_.addAll(other.sha256WithEcdsa_);
            }
            onChanged();
          }
        } else {
          if (!other.sha256WithEcdsa_.isEmpty()) {
            if (sha256WithEcdsaBuilder_.isEmpty()) {
              sha256WithEcdsaBuilder_.dispose();
              sha256WithEcdsaBuilder_ = null;
              sha256WithEcdsa_ = other.sha256WithEcdsa_;
              bitField0_ = (bitField0_ & ~0x00000002);
              sha256WithEcdsaBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSha256WithEcdsaFieldBuilder() : null;
            } else {
              sha256WithEcdsaBuilder_.addAllMessages(other.sha256WithEcdsa_);
            }
          }
        }
        if (other.hasSignedHeaderData()) {
          setSignedHeaderData(other.getSignedHeaderData());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.github.mike10004.crxtool.message.Crx3.CrxFileHeader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.github.mike10004.crxtool.message.Crx3.CrxFileHeader) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> sha256WithRsa_ =
        java.util.Collections.emptyList();
      private void ensureSha256WithRsaIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          sha256WithRsa_ = new java.util.ArrayList<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof>(sha256WithRsa_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> sha256WithRsaBuilder_;

      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithRsaList() {
        if (sha256WithRsaBuilder_ == null) {
          return java.util.Collections.unmodifiableList(sha256WithRsa_);
        } else {
          return sha256WithRsaBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public int getSha256WithRsaCount() {
        if (sha256WithRsaBuilder_ == null) {
          return sha256WithRsa_.size();
        } else {
          return sha256WithRsaBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithRsa(int index) {
        if (sha256WithRsaBuilder_ == null) {
          return sha256WithRsa_.get(index);
        } else {
          return sha256WithRsaBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder setSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        if (sha256WithRsaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSha256WithRsaIsMutable();
          sha256WithRsa_.set(index, value);
          onChanged();
        } else {
          sha256WithRsaBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder setSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        if (sha256WithRsaBuilder_ == null) {
          ensureSha256WithRsaIsMutable();
          sha256WithRsa_.set(index, builderForValue.build());
          onChanged();
        } else {
          sha256WithRsaBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        if (sha256WithRsaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSha256WithRsaIsMutable();
          sha256WithRsa_.add(value);
          onChanged();
        } else {
          sha256WithRsaBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        if (sha256WithRsaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSha256WithRsaIsMutable();
          sha256WithRsa_.add(index, value);
          onChanged();
        } else {
          sha256WithRsaBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        if (sha256WithRsaBuilder_ == null) {
          ensureSha256WithRsaIsMutable();
          sha256WithRsa_.add(builderForValue.build());
          onChanged();
        } else {
          sha256WithRsaBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        if (sha256WithRsaBuilder_ == null) {
          ensureSha256WithRsaIsMutable();
          sha256WithRsa_.add(index, builderForValue.build());
          onChanged();
        } else {
          sha256WithRsaBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addAllSha256WithRsa(
          java.lang.Iterable<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> values) {
        if (sha256WithRsaBuilder_ == null) {
          ensureSha256WithRsaIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, sha256WithRsa_);
          onChanged();
        } else {
          sha256WithRsaBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder clearSha256WithRsa() {
        if (sha256WithRsaBuilder_ == null) {
          sha256WithRsa_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          sha256WithRsaBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder removeSha256WithRsa(int index) {
        if (sha256WithRsaBuilder_ == null) {
          ensureSha256WithRsaIsMutable();
          sha256WithRsa_.remove(index);
          onChanged();
        } else {
          sha256WithRsaBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder getSha256WithRsaBuilder(
          int index) {
        return getSha256WithRsaFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithRsaOrBuilder(
          int index) {
        if (sha256WithRsaBuilder_ == null) {
          return sha256WithRsa_.get(index);  } else {
          return sha256WithRsaBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
           getSha256WithRsaOrBuilderList() {
        if (sha256WithRsaBuilder_ != null) {
          return sha256WithRsaBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(sha256WithRsa_);
        }
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder addSha256WithRsaBuilder() {
        return getSha256WithRsaFieldBuilder().addBuilder(
            io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.getDefaultInstance());
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder addSha256WithRsaBuilder(
          int index) {
        return getSha256WithRsaFieldBuilder().addBuilder(
            index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.getDefaultInstance());
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder> 
           getSha256WithRsaBuilderList() {
        return getSha256WithRsaFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
          getSha256WithRsaFieldBuilder() {
        if (sha256WithRsaBuilder_ == null) {
          sha256WithRsaBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder>(
                  sha256WithRsa_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          sha256WithRsa_ = null;
        }
        return sha256WithRsaBuilder_;
      }

      private java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> sha256WithEcdsa_ =
        java.util.Collections.emptyList();
      private void ensureSha256WithEcdsaIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          sha256WithEcdsa_ = new java.util.ArrayList<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof>(sha256WithEcdsa_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> sha256WithEcdsaBuilder_;

      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> getSha256WithEcdsaList() {
        if (sha256WithEcdsaBuilder_ == null) {
          return java.util.Collections.unmodifiableList(sha256WithEcdsa_);
        } else {
          return sha256WithEcdsaBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public int getSha256WithEcdsaCount() {
        if (sha256WithEcdsaBuilder_ == null) {
          return sha256WithEcdsa_.size();
        } else {
          return sha256WithEcdsaBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index) {
        if (sha256WithEcdsaBuilder_ == null) {
          return sha256WithEcdsa_.get(index);
        } else {
          return sha256WithEcdsaBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder setSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        if (sha256WithEcdsaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSha256WithEcdsaIsMutable();
          sha256WithEcdsa_.set(index, value);
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder setSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        if (sha256WithEcdsaBuilder_ == null) {
          ensureSha256WithEcdsaIsMutable();
          sha256WithEcdsa_.set(index, builderForValue.build());
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        if (sha256WithEcdsaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSha256WithEcdsaIsMutable();
          sha256WithEcdsa_.add(value);
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof value) {
        if (sha256WithEcdsaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSha256WithEcdsaIsMutable();
          sha256WithEcdsa_.add(index, value);
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        if (sha256WithEcdsaBuilder_ == null) {
          ensureSha256WithEcdsaIsMutable();
          sha256WithEcdsa_.add(builderForValue.build());
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          int index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        if (sha256WithEcdsaBuilder_ == null) {
          ensureSha256WithEcdsaIsMutable();
          sha256WithEcdsa_.add(index, builderForValue.build());
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addAllSha256WithEcdsa(
          java.lang.Iterable<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof> values) {
        if (sha256WithEcdsaBuilder_ == null) {
          ensureSha256WithEcdsaIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, sha256WithEcdsa_);
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder clearSha256WithEcdsa() {
        if (sha256WithEcdsaBuilder_ == null) {
          sha256WithEcdsa_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder removeSha256WithEcdsa(int index) {
        if (sha256WithEcdsaBuilder_ == null) {
          ensureSha256WithEcdsaIsMutable();
          sha256WithEcdsa_.remove(index);
          onChanged();
        } else {
          sha256WithEcdsaBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder getSha256WithEcdsaBuilder(
          int index) {
        return getSha256WithEcdsaFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder getSha256WithEcdsaOrBuilder(
          int index) {
        if (sha256WithEcdsaBuilder_ == null) {
          return sha256WithEcdsa_.get(index);  } else {
          return sha256WithEcdsaBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public java.util.List<? extends io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
           getSha256WithEcdsaOrBuilderList() {
        if (sha256WithEcdsaBuilder_ != null) {
          return sha256WithEcdsaBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(sha256WithEcdsa_);
        }
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder addSha256WithEcdsaBuilder() {
        return getSha256WithEcdsaFieldBuilder().addBuilder(
            io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.getDefaultInstance());
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder addSha256WithEcdsaBuilder(
          int index) {
        return getSha256WithEcdsaFieldBuilder().addBuilder(
            index, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.getDefaultInstance());
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public java.util.List<io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder> 
           getSha256WithEcdsaBuilderList() {
        return getSha256WithEcdsaFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder> 
          getSha256WithEcdsaFieldBuilder() {
        if (sha256WithEcdsaBuilder_ == null) {
          sha256WithEcdsaBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder>(
                  sha256WithEcdsa_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          sha256WithEcdsa_ = null;
        }
        return sha256WithEcdsaBuilder_;
      }

      private com.google.protobuf.ByteString signedHeaderData_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @return Whether the signedHeaderData field is set.
       */
      public boolean hasSignedHeaderData() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @return The signedHeaderData.
       */
      public com.google.protobuf.ByteString getSignedHeaderData() {
        return signedHeaderData_;
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @param value The signedHeaderData to set.
       * @return This builder for chaining.
       */
      public Builder setSignedHeaderData(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        signedHeaderData_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignedHeaderData() {
        bitField0_ = (bitField0_ & ~0x00000004);
        signedHeaderData_ = getDefaultInstance().getSignedHeaderData();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:crx_file.CrxFileHeader)
    }

    // @@protoc_insertion_point(class_scope:crx_file.CrxFileHeader)
    private static final io.github.mike10004.crxtool.message.Crx3.CrxFileHeader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.github.mike10004.crxtool.message.Crx3.CrxFileHeader();
    }

    public static io.github.mike10004.crxtool.message.Crx3.CrxFileHeader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CrxFileHeader>
        PARSER = new com.google.protobuf.AbstractParser<CrxFileHeader>() {
      @java.lang.Override
      public CrxFileHeader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CrxFileHeader(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CrxFileHeader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CrxFileHeader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.github.mike10004.crxtool.message.Crx3.CrxFileHeader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AsymmetricKeyProofOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.AsymmetricKeyProof)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional bytes public_key = 1;</code>
     * @return Whether the publicKey field is set.
     */
    boolean hasPublicKey();
    /**
     * <code>optional bytes public_key = 1;</code>
     * @return The publicKey.
     */
    com.google.protobuf.ByteString getPublicKey();

    /**
     * <code>optional bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    boolean hasSignature();
    /**
     * <code>optional bytes signature = 2;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * Protobuf type {@code crx_file.AsymmetricKeyProof}
   */
  public  static final class AsymmetricKeyProof extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:crx_file.AsymmetricKeyProof)
      AsymmetricKeyProofOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AsymmetricKeyProof.newBuilder() to construct.
    private AsymmetricKeyProof(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AsymmetricKeyProof() {
      publicKey_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AsymmetricKeyProof();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AsymmetricKeyProof(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              bitField0_ |= 0x00000001;
              publicKey_ = input.readBytes();
              break;
            }
            case 18: {
              bitField0_ |= 0x00000002;
              signature_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_AsymmetricKeyProof_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_AsymmetricKeyProof_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.class, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder.class);
    }

    private int bitField0_;
    public static final int PUBLIC_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString publicKey_;
    /**
     * <code>optional bytes public_key = 1;</code>
     * @return Whether the publicKey field is set.
     */
    public boolean hasPublicKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional bytes public_key = 1;</code>
     * @return The publicKey.
     */
    public com.google.protobuf.ByteString getPublicKey() {
      return publicKey_;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString signature_;
    /**
     * <code>optional bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bytes signature = 2;</code>
     * @return The signature.
     */
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, publicKey_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, signature_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, publicKey_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, signature_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof)) {
        return super.equals(obj);
      }
      io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof other = (io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof) obj;

      if (hasPublicKey() != other.hasPublicKey()) return false;
      if (hasPublicKey()) {
        if (!getPublicKey()
            .equals(other.getPublicKey())) return false;
      }
      if (hasSignature() != other.hasSignature()) return false;
      if (hasSignature()) {
        if (!getSignature()
            .equals(other.getSignature())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPublicKey()) {
        hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getPublicKey().hashCode();
      }
      if (hasSignature()) {
        hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
        hash = (53 * hash) + getSignature().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code crx_file.AsymmetricKeyProof}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.AsymmetricKeyProof)
        io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProofOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_AsymmetricKeyProof_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_AsymmetricKeyProof_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.class, io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.Builder.class);
      }

      // Construct using io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        publicKey_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        signature_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_AsymmetricKeyProof_descriptor;
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getDefaultInstanceForType() {
        return io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.getDefaultInstance();
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof build() {
        io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof buildPartial() {
        io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof result = new io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.publicKey_ = publicKey_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.signature_ = signature_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof) {
          return mergeFrom((io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof other) {
        if (other == io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof.getDefaultInstance()) return this;
        if (other.hasPublicKey()) {
          setPublicKey(other.getPublicKey());
        }
        if (other.hasSignature()) {
          setSignature(other.getSignature());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString publicKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes public_key = 1;</code>
       * @return Whether the publicKey field is set.
       */
      public boolean hasPublicKey() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       * @return The publicKey.
       */
      public com.google.protobuf.ByteString getPublicKey() {
        return publicKey_;
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       * @param value The publicKey to set.
       * @return This builder for chaining.
       */
      public Builder setPublicKey(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        publicKey_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        publicKey_ = getDefaultInstance().getPublicKey();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes signature = 2;</code>
       * @return Whether the signature field is set.
       */
      public boolean hasSignature() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bytes signature = 2;</code>
       * @return The signature.
       */
      public com.google.protobuf.ByteString getSignature() {
        return signature_;
      }
      /**
       * <code>optional bytes signature = 2;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        signature_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes signature = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        bitField0_ = (bitField0_ & ~0x00000002);
        signature_ = getDefaultInstance().getSignature();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:crx_file.AsymmetricKeyProof)
    }

    // @@protoc_insertion_point(class_scope:crx_file.AsymmetricKeyProof)
    private static final io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof();
    }

    public static io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<AsymmetricKeyProof>
        PARSER = new com.google.protobuf.AbstractParser<AsymmetricKeyProof>() {
      @java.lang.Override
      public AsymmetricKeyProof parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AsymmetricKeyProof(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AsymmetricKeyProof> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AsymmetricKeyProof> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.github.mike10004.crxtool.message.Crx3.AsymmetricKeyProof getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignedDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.SignedData)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return Whether the crxId field is set.
     */
    boolean hasCrxId();
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return The crxId.
     */
    com.google.protobuf.ByteString getCrxId();
  }
  /**
   * Protobuf type {@code crx_file.SignedData}
   */
  public  static final class SignedData extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:crx_file.SignedData)
      SignedDataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SignedData.newBuilder() to construct.
    private SignedData(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SignedData() {
      crxId_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SignedData();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SignedData(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              bitField0_ |= 0x00000001;
              crxId_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_SignedData_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_SignedData_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.github.mike10004.crxtool.message.Crx3.SignedData.class, io.github.mike10004.crxtool.message.Crx3.SignedData.Builder.class);
    }

    private int bitField0_;
    public static final int CRX_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString crxId_;
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return Whether the crxId field is set.
     */
    public boolean hasCrxId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return The crxId.
     */
    public com.google.protobuf.ByteString getCrxId() {
      return crxId_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, crxId_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, crxId_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.github.mike10004.crxtool.message.Crx3.SignedData)) {
        return super.equals(obj);
      }
      io.github.mike10004.crxtool.message.Crx3.SignedData other = (io.github.mike10004.crxtool.message.Crx3.SignedData) obj;

      if (hasCrxId() != other.hasCrxId()) return false;
      if (hasCrxId()) {
        if (!getCrxId()
            .equals(other.getCrxId())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCrxId()) {
        hash = (37 * hash) + CRX_ID_FIELD_NUMBER;
        hash = (53 * hash) + getCrxId().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.github.mike10004.crxtool.message.Crx3.SignedData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.github.mike10004.crxtool.message.Crx3.SignedData prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code crx_file.SignedData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.SignedData)
        io.github.mike10004.crxtool.message.Crx3.SignedDataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_SignedData_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_SignedData_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.github.mike10004.crxtool.message.Crx3.SignedData.class, io.github.mike10004.crxtool.message.Crx3.SignedData.Builder.class);
      }

      // Construct using io.github.mike10004.crxtool.message.Crx3.SignedData.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        crxId_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.github.mike10004.crxtool.message.Crx3.internal_static_crx_file_SignedData_descriptor;
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.SignedData getDefaultInstanceForType() {
        return io.github.mike10004.crxtool.message.Crx3.SignedData.getDefaultInstance();
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.SignedData build() {
        io.github.mike10004.crxtool.message.Crx3.SignedData result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.github.mike10004.crxtool.message.Crx3.SignedData buildPartial() {
        io.github.mike10004.crxtool.message.Crx3.SignedData result = new io.github.mike10004.crxtool.message.Crx3.SignedData(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.crxId_ = crxId_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.github.mike10004.crxtool.message.Crx3.SignedData) {
          return mergeFrom((io.github.mike10004.crxtool.message.Crx3.SignedData)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.github.mike10004.crxtool.message.Crx3.SignedData other) {
        if (other == io.github.mike10004.crxtool.message.Crx3.SignedData.getDefaultInstance()) return this;
        if (other.hasCrxId()) {
          setCrxId(other.getCrxId());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.github.mike10004.crxtool.message.Crx3.SignedData parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.github.mike10004.crxtool.message.Crx3.SignedData) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString crxId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @return Whether the crxId field is set.
       */
      public boolean hasCrxId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @return The crxId.
       */
      public com.google.protobuf.ByteString getCrxId() {
        return crxId_;
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @param value The crxId to set.
       * @return This builder for chaining.
       */
      public Builder setCrxId(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        crxId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCrxId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        crxId_ = getDefaultInstance().getCrxId();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:crx_file.SignedData)
    }

    // @@protoc_insertion_point(class_scope:crx_file.SignedData)
    private static final io.github.mike10004.crxtool.message.Crx3.SignedData DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.github.mike10004.crxtool.message.Crx3.SignedData();
    }

    public static io.github.mike10004.crxtool.message.Crx3.SignedData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<SignedData>
        PARSER = new com.google.protobuf.AbstractParser<SignedData>() {
      @java.lang.Override
      public SignedData parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SignedData(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SignedData> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SignedData> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.github.mike10004.crxtool.message.Crx3.SignedData getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_crx_file_CrxFileHeader_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_crx_file_CrxFileHeader_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_crx_file_AsymmetricKeyProof_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_crx_file_AsymmetricKeyProof_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_crx_file_SignedData_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_crx_file_SignedData_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\030main/chromium/crx3.proto\022\010crx_file\"\234\001\n" +
      "\rCrxFileHeader\0225\n\017sha256_with_rsa\030\002 \003(\0132" +
      "\034.crx_file.AsymmetricKeyProof\0227\n\021sha256_" +
      "with_ecdsa\030\003 \003(\0132\034.crx_file.AsymmetricKe" +
      "yProof\022\033\n\022signed_header_data\030\220N \001(\014\";\n\022A" +
      "symmetricKeyProof\022\022\n\npublic_key\030\001 \001(\014\022\021\n" +
      "\tsignature\030\002 \001(\014\"\034\n\nSignedData\022\016\n\006crx_id" +
      "\030\001 \001(\014B-\n#io.github.mike10004.crxtool.me" +
      "ssageB\004Crx3H\003"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_crx_file_CrxFileHeader_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_crx_file_CrxFileHeader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_crx_file_CrxFileHeader_descriptor,
        new java.lang.String[] { "Sha256WithRsa", "Sha256WithEcdsa", "SignedHeaderData", });
    internal_static_crx_file_AsymmetricKeyProof_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_crx_file_AsymmetricKeyProof_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_crx_file_AsymmetricKeyProof_descriptor,
        new java.lang.String[] { "PublicKey", "Signature", });
    internal_static_crx_file_SignedData_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_crx_file_SignedData_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_crx_file_SignedData_descriptor,
        new java.lang.String[] { "CrxId", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
